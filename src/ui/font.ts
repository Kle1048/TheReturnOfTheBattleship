import { fillRect } from "../engine/render/blit";

// Simple 8x8 pixel font - each character is 8x8 pixels
const CHAR_WIDTH = 8;
const CHAR_HEIGHT = 8;

// Simple bitmap font data (6x8 pixels per char, stored as binary patterns)
const FONT_DATA: { [key: string]: number[] } = {
  '0': [0x3e, 0x63, 0x73, 0x7b, 0x6f, 0x67, 0x63, 0x3e],
  '1': [0x0c, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3f],
  '2': [0x1e, 0x33, 0x30, 0x1c, 0x06, 0x03, 0x33, 0x3f],
  '3': [0x1e, 0x33, 0x30, 0x1c, 0x30, 0x30, 0x33, 0x1e],
  '4': [0x38, 0x3c, 0x36, 0x33, 0x7f, 0x30, 0x30, 0x78],
  '5': [0x3f, 0x03, 0x03, 0x1f, 0x30, 0x30, 0x33, 0x1e],
  '6': [0x1c, 0x06, 0x03, 0x1f, 0x33, 0x33, 0x33, 0x1e],
  '7': [0x3f, 0x33, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c],
  '8': [0x1e, 0x33, 0x33, 0x1e, 0x33, 0x33, 0x33, 0x1e],
  '9': [0x1e, 0x33, 0x33, 0x33, 0x3e, 0x30, 0x18, 0x0e],
  'A': [0x0c, 0x1e, 0x33, 0x33, 0x3f, 0x33, 0x33, 0x33],
  'B': [0x1f, 0x33, 0x33, 0x1f, 0x33, 0x33, 0x33, 0x1f],
  'C': [0x1e, 0x33, 0x03, 0x03, 0x03, 0x03, 0x33, 0x1e],
  'D': [0x1f, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x1f],
  'E': [0x3f, 0x03, 0x03, 0x1f, 0x03, 0x03, 0x03, 0x3f],
  'F': [0x3f, 0x03, 0x03, 0x1f, 0x03, 0x03, 0x03, 0x03],
  'G': [0x1e, 0x33, 0x03, 0x03, 0x3b, 0x33, 0x33, 0x1e],
  'H': [0x33, 0x33, 0x33, 0x3f, 0x33, 0x33, 0x33, 0x33],
  'I': [0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x1e],
  'J': [0x3c, 0x18, 0x18, 0x18, 0x18, 0x1b, 0x1b, 0x0e],
  'K': [0x33, 0x1b, 0x0f, 0x07, 0x0f, 0x1b, 0x33, 0x33],
  'L': [0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x3f],
  'M': [0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x63, 0x63],
  'N': [0x33, 0x37, 0x3f, 0x3b, 0x33, 0x33, 0x33, 0x33],
  'O': [0x1e, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x1e],
  'P': [0x1f, 0x33, 0x33, 0x1f, 0x03, 0x03, 0x03, 0x03],
  'Q': [0x1e, 0x33, 0x33, 0x33, 0x33, 0x3b, 0x1e, 0x38],
  'R': [0x1f, 0x33, 0x33, 0x1f, 0x0f, 0x1b, 0x33, 0x33],
  'S': [0x1e, 0x33, 0x03, 0x1e, 0x30, 0x30, 0x33, 0x1e],
  'T': [0x3f, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c],
  'U': [0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x1e],
  'V': [0x33, 0x33, 0x33, 0x33, 0x33, 0x1e, 0x0c, 0x0c],
  'W': [0x63, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x63],
  'X': [0x33, 0x33, 0x1e, 0x0c, 0x0c, 0x1e, 0x33, 0x33],
  'Y': [0x33, 0x33, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c],
  'Z': [0x3f, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x3f],
  ':': [0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00],
  ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  '-': [0x00, 0x00, 0x00, 0x3f, 0x3f, 0x00, 0x00, 0x00],
};

export function renderText(fb: Uint8Array, text: string, x: number, y: number, color: number) {
  let posX = x;
  
  for (let i = 0; i < text.length; i++) {
    const char = text[i].toUpperCase();
    renderChar(fb, char, posX, y, color);
    posX += CHAR_WIDTH;
  }
}

function renderChar(fb: Uint8Array, char: string, x: number, y: number, color: number) {
  const W = 320;
  const H = 200;
  
  const fontData = FONT_DATA[char];
  if (!fontData) {
    // Unknown character - render as space
    return;
  }
  
  // Render 8x8 font pattern
  // Font data: each byte represents one row, all 8 bits are used
  // The font data uses MSB (bit 7) as leftmost pixel, LSB (bit 0) as rightmost
  // To fix mirroring: read bits normally but reverse the column position
  for (let row = 0; row < 8; row++) {
    const rowData = fontData[row];
    for (let col = 0; col < 8; col++) {
      // Read bits from left to right: bit 7 is leftmost, bit 0 is rightmost
      const bitIndex = 7 - col; // col 0 reads bit 7, col 7 reads bit 0
      const bit = (rowData >> bitIndex) & 1;
      if (bit) {
        // Reverse column position to fix mirroring (so bit 7 renders at rightmost position)
        const px = x + (7 - col);
        const py = y + row;
        if (px >= 0 && px < W && py >= 0 && py < H) {
          fb[py * W + px] = color;
        }
      }
    }
  }
}
